#!/usr/bin/env python3

import os, sys
import json
from typing import List
import streamlit as st
from streamlit_agraph import agraph, Node, Edge, Config
import streamlit.components.v1 as components
from pyvis.network import Network
from pyvis import network as net

from langchain.chat_models import ChatOpenAI
from langchain.schema import HumanMessage
from langchain.prompts import ChatPromptTemplate
from langchain.prompts import PromptTemplate
from langchain.schema import BaseOutputParser



st.set_page_config(page_title="SciMap", page_icon=":robot:", layout="wide", initial_sidebar_state="collapsed")
st.header("SciMapAI: Creating text-based knowledge graphs using AI")
st.write("Exploring scientific texts and concepts through interactive knowledge graphs generated by AI.")

st.sidebar.markdown("SciMapAI uses OpenAIs GPT-4 model, to extract concepts and their relationships from scientific texts. It aims to provide a visual way of understanding complex texts, by leveraging knowlegde graphs.")
st.sidebar.markdown("Created by Philip Wolper [phi.wolper@tum.de](phi.wolper@tum.de). Code is available on [GitHub](https://github.com/pwolper/scimapai.git) here. Feeback is very welcome.")
st.sidebar.markdown("**Knowledge Graph Options**")
debug=st.sidebar.checkbox("Show debugging information")

def get_text():
    input_text = st.text_area(label="Text Input", label_visibility='collapsed',
                              placeholder="Paste a scientific text...", key="text_input",
                              height=300)
    # if not input_text:
    #     with open('abstract_bacteria.txt', 'r') as file:
    #         example = file.read().strip()
    #     return example

    return(input_text)


@st.cache_data
def get_api_key():
    if not os.getenv("OPENAI_API_KEY"):
        openai_api_key=st.text_input(label="OpenAI API Key ",  placeholder="Ex: sk-2twmA8tfCb8un4...", key="openai_api_key_input")
    else:
        openai_api_key=os.getenv("OPENAI_API_KEY")
    return(openai_api_key)

@st.cache_data
def llm_network_call(text_input):
    llm = ChatOpenAI(model_name="gpt-4-1106-preview", temperature=0, openai_api_key=openai_api_key)

    mapping_template = """
    You are an scientific assistant, tasked with extracting the main concepts and key words from articles and abstracts. I want to create a concept map to enhance understanding of the text.
    Breaking down the text hierarchically and semantically, I want you to choose high-level concepts as nodes, avoiding overlap between concepts. Keep the number of nodes to a minimum.
    Concepts should be as atomistic as possible, but chosen so that there is high connectivity in the graph.
    Return nodes and edges for the concept map and come up with a sentence explaining each edge as well.
    Text: {text}

    Strictly return a list of json objects, with the following fields:
    "node_1", "node_2" and "edge". Where "node_1" and "node_2", represent two nodes and "edge" is a string containing a sentence describing the relationship between the nodes.
    Do not wrap the output in ```json ```.
    """

    mapping_prompt = ChatPromptTemplate.from_messages(
        [("system", mapping_template),
         ("human", "{text}"),
         ])

    messages = mapping_prompt.format_messages(text=text_input)
    answer = llm(messages)
    output = answer.content
    return(output)

@st.cache_data
def llm_summary_call(text_input):
    llm = ChatOpenAI(model_name="gpt-4-1106-preview", temperature=0.5)

    summary_template = """
    You are an scientific assistant, tasked with summarizing a scientific text. When summarizing make sure to mention, the research aims, methods and results.
    Also mention how the results can be interpreted in the broader picture of the research area. Return a short summary of the text.
    Text: {text}
    """

    summary_prompt = ChatPromptTemplate.from_messages(
        [("system", summary_template),
         ("human", "{text}"),
         ])

    summary_message = summary_prompt.format_messages(text=text_input)
    answer = llm(summary_message)
    output = answer.content
    return(output)

text_input = get_text()

openai_api_key = get_api_key()

if text_input:
    if not openai_api_key:
        st.warning('Please insert OpenAI API Key. Instructions [here](https://help.openai.com/en/articles/4936850-where-do-i-find-my-secret-api-key)', icon="⚠️")
        st.stop()
    mapping_output = llm_network_call(text_input)
    summary = llm_summary_call(text_input)
else:
    st.stop()

def json_parsing(mapping_output):
    output_dict = json.loads(mapping_output)


    nodes = []
    edges = []

    for dict in output_dict:
        node_1 = dict['node_1']
        node_2 = dict['node_2']
        edge = dict['edge']

        nodes.append(node_1)
        nodes.append(node_2)

        edges.append((node_1, node_2, edge))

    return(nodes, edges)

nodes, edges = json_parsing(mapping_output)

def pyvis_graph(nodes, edges):
    nt = Network(directed=False,
                 notebook=True,height="540px",width="1349px",
                #height="480px",
                #width="620px",
                #width="940px",
                heading='')

    for n in nodes:
        nt.add_node(n,
                    title=n,
                    size=15)

    for source, target, label in edges:
        nt.add_edge(source,
                    target,
                    title=label)


    # nt.barnes_hut()
    nt.show('pyvis_knowledge_graph.html')
    html_file = open('./pyvis_knowledge_graph.html', 'r', encoding='utf-8')
    source_code = html_file.read()
    return(source_code)

source_code=pyvis_graph(nodes, edges)

# col1, col2 = st.columns(2)

# with col2:
    # components.html(source_code, height=450,width=650)
st.markdown("**Knowledge Graph:**")
components.html(source_code, height=550,width=1350)

# with col1:
st.markdown("**Summary:**")
st.markdown(summary)



if debug:
    with st.expander("**LLM output and Data Structure**"):
        st.markdown("**LLM output:**")
        st.markdown(mapping_output)
        st.markdown("**Nodes:**")
        st.write(nodes)
        st.markdown("**Edges:**")
        st.write(edges)
